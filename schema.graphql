### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AggregateCategory {
  _avg: CategoryAvgAggregateOutputType
  _count: CategoryCountAggregateOutputType
  _max: CategoryMaxAggregateOutputType
  _min: CategoryMinAggregateOutputType
  _sum: CategorySumAggregateOutputType
}

type AggregateDonation {
  _avg: DonationAvgAggregateOutputType
  _count: DonationCountAggregateOutputType
  _max: DonationMaxAggregateOutputType
  _min: DonationMinAggregateOutputType
  _sum: DonationSumAggregateOutputType
}

type AggregateDonationAccount {
  _avg: DonationAccountAvgAggregateOutputType
  _count: DonationAccountCountAggregateOutputType
  _max: DonationAccountMaxAggregateOutputType
  _min: DonationAccountMinAggregateOutputType
  _sum: DonationAccountSumAggregateOutputType
}

type AggregateNews {
  _avg: NewsAvgAggregateOutputType
  _count: NewsCountAggregateOutputType
  _max: NewsMaxAggregateOutputType
  _min: NewsMinAggregateOutputType
  _sum: NewsSumAggregateOutputType
}

type AggregateUser {
  _avg: UserAvgAggregateOutputType
  _count: UserCountAggregateOutputType
  _max: UserMaxAggregateOutputType
  _min: UserMinAggregateOutputType
  _sum: UserSumAggregateOutputType
}

type BatchPayload {
  count: Int!
}

"""BigInt custom scalar type"""
scalar BigInt

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

type Category {
  _count: CategoryCountOutputType!
  id: Int!
  name: String!
  news(cursor: NewsWhereUniqueInput, distinct: NewsScalarFieldEnum, orderBy: NewsOrderByWithRelationInput, skip: Int, take: Int, where: NewsWhereInput): [News!]!
}

type CategoryAvgAggregateOutputType {
  id: Float
}

input CategoryAvgOrderByAggregateInput {
  id: SortOrder
}

type CategoryCountAggregateOutputType {
  _all: Int!
  id: Int!
  name: Int!
}

input CategoryCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

type CategoryCountOutputType {
  news: Int!
}

input CategoryCreateInput {
  name: String!
  news: NewsCreateNestedManyWithoutCategoriesInput
}

input CategoryCreateManyInput {
  id: Int
  name: String!
}

input CategoryCreateNestedManyWithoutNewsInput {
  connect: [CategoryWhereUniqueInput]
  connectOrCreate: [CategoryCreateOrConnectWithoutNewsInput]
  create: [CategoryCreateWithoutNewsInput]
}

input CategoryCreateOrConnectWithoutNewsInput {
  create: CategoryUncheckedCreateWithoutNewsInput!
  where: CategoryWhereUniqueInput!
}

input CategoryCreateWithoutNewsInput {
  name: String!
}

input CategoryListRelationFilter {
  every: CategoryWhereInput
  none: CategoryWhereInput
  some: CategoryWhereInput
}

type CategoryMaxAggregateOutputType {
  id: Int
  name: String
}

input CategoryMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

type CategoryMinAggregateOutputType {
  id: Int
  name: String
}

input CategoryMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input CategoryOrderByRelationAggregateInput {
  _count: SortOrder
}

input CategoryOrderByWithAggregationInput {
  _avg: CategoryAvgOrderByAggregateInput
  _count: CategoryCountOrderByAggregateInput
  _max: CategoryMaxOrderByAggregateInput
  _min: CategoryMinOrderByAggregateInput
  _sum: CategorySumOrderByAggregateInput
  id: SortOrder
  name: SortOrder
}

input CategoryOrderByWithRelationInput {
  id: SortOrder
  name: SortOrder
  news: NewsOrderByRelationAggregateInput
}

enum CategoryScalarFieldEnum {
  id
  name
}

input CategoryScalarWhereInput {
  AND: [CategoryScalarWhereInput]
  NOT: [CategoryScalarWhereInput]
  OR: [CategoryScalarWhereInput]
  id: IntFilter
  name: StringFilter
}

input CategoryScalarWhereWithAggregatesInput {
  AND: [CategoryScalarWhereWithAggregatesInput]
  NOT: [CategoryScalarWhereWithAggregatesInput]
  OR: [CategoryScalarWhereWithAggregatesInput]
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type CategorySumAggregateOutputType {
  id: Int
}

input CategorySumOrderByAggregateInput {
  id: SortOrder
}

input CategoryUncheckedCreateInput {
  id: Int
  name: String!
  news: NewsUncheckedCreateNestedManyWithoutCategoriesInput
}

input CategoryUncheckedCreateNestedManyWithoutNewsInput {
  connect: [CategoryWhereUniqueInput]
  connectOrCreate: [CategoryCreateOrConnectWithoutNewsInput]
  create: [CategoryCreateWithoutNewsInput]
}

input CategoryUncheckedCreateWithoutNewsInput {
  id: Int
  name: String!
}

input CategoryUncheckedUpdateInput {
  id: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  news: NewsUncheckedUpdateManyWithoutCategoriesInput
}

input CategoryUncheckedUpdateManyInput {
  id: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input CategoryUncheckedUpdateManyWithoutCategoriesInput {
  id: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input CategoryUncheckedUpdateManyWithoutNewsInput {
  connect: [CategoryWhereUniqueInput]
  connectOrCreate: [CategoryCreateOrConnectWithoutNewsInput]
  create: [CategoryCreateWithoutNewsInput]
  delete: [CategoryWhereUniqueInput]
  deleteMany: [CategoryScalarWhereInput]
  disconnect: [CategoryWhereUniqueInput]
  set: [CategoryWhereUniqueInput]
  update: [CategoryUpdateWithWhereUniqueWithoutNewsInput]
  updateMany: [CategoryUpdateManyWithWhereWithoutNewsInput]
  upsert: [CategoryUpsertWithWhereUniqueWithoutNewsInput]
}

input CategoryUncheckedUpdateWithoutNewsInput {
  id: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input CategoryUpdateInput {
  name: StringFieldUpdateOperationsInput
  news: NewsUpdateManyWithoutCategoriesInput
}

input CategoryUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
}

input CategoryUpdateManyWithWhereWithoutNewsInput {
  data: CategoryUncheckedUpdateManyWithoutCategoriesInput!
  where: CategoryScalarWhereInput!
}

input CategoryUpdateManyWithoutNewsInput {
  connect: [CategoryWhereUniqueInput]
  connectOrCreate: [CategoryCreateOrConnectWithoutNewsInput]
  create: [CategoryCreateWithoutNewsInput]
  delete: [CategoryWhereUniqueInput]
  deleteMany: [CategoryScalarWhereInput]
  disconnect: [CategoryWhereUniqueInput]
  set: [CategoryWhereUniqueInput]
  update: [CategoryUpdateWithWhereUniqueWithoutNewsInput]
  updateMany: [CategoryUpdateManyWithWhereWithoutNewsInput]
  upsert: [CategoryUpsertWithWhereUniqueWithoutNewsInput]
}

input CategoryUpdateWithWhereUniqueWithoutNewsInput {
  data: CategoryUncheckedUpdateWithoutNewsInput!
  where: CategoryWhereUniqueInput!
}

input CategoryUpdateWithoutNewsInput {
  name: StringFieldUpdateOperationsInput
}

input CategoryUpsertWithWhereUniqueWithoutNewsInput {
  create: CategoryUncheckedCreateWithoutNewsInput!
  update: CategoryUncheckedUpdateWithoutNewsInput!
  where: CategoryWhereUniqueInput!
}

input CategoryWhereInput {
  AND: [CategoryWhereInput]
  NOT: [CategoryWhereInput]
  OR: [CategoryWhereInput]
  id: IntFilter
  name: StringFilter
  news: NewsListRelationFilter
}

input CategoryWhereUniqueInput {
  id: Int
}

"""Date custom scalar type"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime]
}

"""Decimal custom scalar type"""
scalar Decimal

type Donation {
  account: DonationAccount!
  accountId: Int!
  amount: Float!
  approvedBy: User
  approvedById: Int
  createdAt: DateTime!
  id: Int!
  name: String!
  status: DonationStatus!
  updatedAt: DateTime!
}

type DonationAccount {
  _count: DonationAccountCountOutputType!
  accountNumber: String!
  bankName: String!
  donations(cursor: DonationWhereUniqueInput, distinct: DonationScalarFieldEnum, orderBy: DonationOrderByWithRelationInput, skip: Int, take: Int, where: DonationWhereInput): [Donation!]!
  id: Int!
  logoUrl: String!
  name: String!
}

type DonationAccountAvgAggregateOutputType {
  id: Float
}

input DonationAccountAvgOrderByAggregateInput {
  id: SortOrder
}

type DonationAccountCountAggregateOutputType {
  _all: Int!
  accountNumber: Int!
  bankName: Int!
  id: Int!
  logoUrl: Int!
  name: Int!
}

input DonationAccountCountOrderByAggregateInput {
  accountNumber: SortOrder
  bankName: SortOrder
  id: SortOrder
  logoUrl: SortOrder
  name: SortOrder
}

type DonationAccountCountOutputType {
  donations: Int!
}

input DonationAccountCreateInput {
  accountNumber: String!
  bankName: String!
  donations: DonationCreateNestedManyWithoutAccountInput
  logoUrl: String!
  name: String!
}

input DonationAccountCreateManyInput {
  accountNumber: String!
  bankName: String!
  id: Int
  logoUrl: String!
  name: String!
}

input DonationAccountCreateNestedOneWithoutDonationsInput {
  connect: DonationAccountWhereUniqueInput
  connectOrCreate: DonationAccountCreateOrConnectWithoutDonationsInput
  create: DonationAccountUncheckedCreateWithoutDonationsInput
}

input DonationAccountCreateOrConnectWithoutDonationsInput {
  create: DonationAccountUncheckedCreateWithoutDonationsInput!
  where: DonationAccountWhereUniqueInput!
}

input DonationAccountCreateWithoutDonationsInput {
  accountNumber: String!
  bankName: String!
  logoUrl: String!
  name: String!
}

type DonationAccountMaxAggregateOutputType {
  accountNumber: String
  bankName: String
  id: Int
  logoUrl: String
  name: String
}

input DonationAccountMaxOrderByAggregateInput {
  accountNumber: SortOrder
  bankName: SortOrder
  id: SortOrder
  logoUrl: SortOrder
  name: SortOrder
}

type DonationAccountMinAggregateOutputType {
  accountNumber: String
  bankName: String
  id: Int
  logoUrl: String
  name: String
}

input DonationAccountMinOrderByAggregateInput {
  accountNumber: SortOrder
  bankName: SortOrder
  id: SortOrder
  logoUrl: SortOrder
  name: SortOrder
}

input DonationAccountOrderByWithAggregationInput {
  _avg: DonationAccountAvgOrderByAggregateInput
  _count: DonationAccountCountOrderByAggregateInput
  _max: DonationAccountMaxOrderByAggregateInput
  _min: DonationAccountMinOrderByAggregateInput
  _sum: DonationAccountSumOrderByAggregateInput
  accountNumber: SortOrder
  bankName: SortOrder
  id: SortOrder
  logoUrl: SortOrder
  name: SortOrder
}

input DonationAccountOrderByWithRelationInput {
  accountNumber: SortOrder
  bankName: SortOrder
  donations: DonationOrderByRelationAggregateInput
  id: SortOrder
  logoUrl: SortOrder
  name: SortOrder
}

input DonationAccountRelationFilter {
  is: DonationAccountWhereInput
  isNot: DonationAccountWhereInput
}

enum DonationAccountScalarFieldEnum {
  accountNumber
  bankName
  id
  logoUrl
  name
}

input DonationAccountScalarWhereWithAggregatesInput {
  AND: [DonationAccountScalarWhereWithAggregatesInput]
  NOT: [DonationAccountScalarWhereWithAggregatesInput]
  OR: [DonationAccountScalarWhereWithAggregatesInput]
  accountNumber: StringWithAggregatesFilter
  bankName: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  logoUrl: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type DonationAccountSumAggregateOutputType {
  id: Int
}

input DonationAccountSumOrderByAggregateInput {
  id: SortOrder
}

input DonationAccountUncheckedCreateInput {
  accountNumber: String!
  bankName: String!
  donations: DonationUncheckedCreateNestedManyWithoutAccountInput
  id: Int
  logoUrl: String!
  name: String!
}

input DonationAccountUncheckedCreateWithoutDonationsInput {
  accountNumber: String!
  bankName: String!
  id: Int
  logoUrl: String!
  name: String!
}

input DonationAccountUncheckedUpdateInput {
  accountNumber: StringFieldUpdateOperationsInput
  bankName: StringFieldUpdateOperationsInput
  donations: DonationUncheckedUpdateManyWithoutAccountInput
  id: IntFieldUpdateOperationsInput
  logoUrl: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input DonationAccountUncheckedUpdateManyInput {
  accountNumber: StringFieldUpdateOperationsInput
  bankName: StringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  logoUrl: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input DonationAccountUncheckedUpdateWithoutDonationsInput {
  accountNumber: StringFieldUpdateOperationsInput
  bankName: StringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  logoUrl: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input DonationAccountUpdateInput {
  accountNumber: StringFieldUpdateOperationsInput
  bankName: StringFieldUpdateOperationsInput
  donations: DonationUpdateManyWithoutAccountInput
  logoUrl: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input DonationAccountUpdateManyMutationInput {
  accountNumber: StringFieldUpdateOperationsInput
  bankName: StringFieldUpdateOperationsInput
  logoUrl: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input DonationAccountUpdateOneRequiredWithoutDonationsInput {
  connect: DonationAccountWhereUniqueInput
  connectOrCreate: DonationAccountCreateOrConnectWithoutDonationsInput
  create: DonationAccountUncheckedCreateWithoutDonationsInput
  update: DonationAccountUncheckedUpdateWithoutDonationsInput
  upsert: DonationAccountUpsertWithoutDonationsInput
}

input DonationAccountUpdateWithoutDonationsInput {
  accountNumber: StringFieldUpdateOperationsInput
  bankName: StringFieldUpdateOperationsInput
  logoUrl: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input DonationAccountUpsertWithoutDonationsInput {
  create: DonationAccountUncheckedCreateWithoutDonationsInput!
  update: DonationAccountUncheckedUpdateWithoutDonationsInput!
}

input DonationAccountWhereInput {
  AND: [DonationAccountWhereInput]
  NOT: [DonationAccountWhereInput]
  OR: [DonationAccountWhereInput]
  accountNumber: StringFilter
  bankName: StringFilter
  donations: DonationListRelationFilter
  id: IntFilter
  logoUrl: StringFilter
  name: StringFilter
}

input DonationAccountWhereUniqueInput {
  id: Int
}

type DonationAvgAggregateOutputType {
  accountId: Float
  amount: Float
  approvedById: Float
  id: Float
}

input DonationAvgOrderByAggregateInput {
  accountId: SortOrder
  amount: SortOrder
  approvedById: SortOrder
  id: SortOrder
}

type DonationCountAggregateOutputType {
  _all: Int!
  accountId: Int!
  amount: Int!
  approvedById: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  status: Int!
  updatedAt: Int!
}

input DonationCountOrderByAggregateInput {
  accountId: SortOrder
  amount: SortOrder
  approvedById: SortOrder
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  status: SortOrder
  updatedAt: SortOrder
}

input DonationCreateInput {
  account: DonationAccountCreateNestedOneWithoutDonationsInput!
  amount: Float!
  approvedBy: UserCreateNestedOneWithoutApprovedDonationsInput
  createdAt: DateTime
  name: String!
  status: DonationStatus!
  updatedAt: DateTime
}

input DonationCreateManyAccountInput {
  amount: Float!
  approvedById: Int
  createdAt: DateTime
  id: Int
  name: String!
  status: DonationStatus!
  updatedAt: DateTime
}

input DonationCreateManyAccountInputEnvelope {
  data: DonationCreateManyAccountInput!
  skipDuplicates: Boolean
}

input DonationCreateManyApprovedByInput {
  accountId: Int!
  amount: Float!
  createdAt: DateTime
  id: Int
  name: String!
  status: DonationStatus!
  updatedAt: DateTime
}

input DonationCreateManyApprovedByInputEnvelope {
  data: DonationCreateManyApprovedByInput!
  skipDuplicates: Boolean
}

input DonationCreateManyInput {
  accountId: Int!
  amount: Float!
  approvedById: Int
  createdAt: DateTime
  id: Int
  name: String!
  status: DonationStatus!
  updatedAt: DateTime
}

input DonationCreateNestedManyWithoutAccountInput {
  connect: [DonationWhereUniqueInput]
  connectOrCreate: [DonationCreateOrConnectWithoutAccountInput]
  create: [DonationCreateWithoutAccountInput]
  createMany: DonationCreateManyAccountInputEnvelope
}

input DonationCreateNestedManyWithoutApprovedByInput {
  connect: [DonationWhereUniqueInput]
  connectOrCreate: [DonationCreateOrConnectWithoutApprovedByInput]
  create: [DonationCreateWithoutApprovedByInput]
  createMany: DonationCreateManyApprovedByInputEnvelope
}

input DonationCreateOrConnectWithoutAccountInput {
  create: DonationUncheckedCreateWithoutAccountInput!
  where: DonationWhereUniqueInput!
}

input DonationCreateOrConnectWithoutApprovedByInput {
  create: DonationUncheckedCreateWithoutApprovedByInput!
  where: DonationWhereUniqueInput!
}

input DonationCreateWithoutAccountInput {
  amount: Float!
  approvedBy: UserCreateNestedOneWithoutApprovedDonationsInput
  createdAt: DateTime
  name: String!
  status: DonationStatus!
  updatedAt: DateTime
}

input DonationCreateWithoutApprovedByInput {
  account: DonationAccountCreateNestedOneWithoutDonationsInput!
  amount: Float!
  createdAt: DateTime
  name: String!
  status: DonationStatus!
  updatedAt: DateTime
}

input DonationListRelationFilter {
  every: DonationWhereInput
  none: DonationWhereInput
  some: DonationWhereInput
}

type DonationMaxAggregateOutputType {
  accountId: Int
  amount: Float
  approvedById: Int
  createdAt: DateTime
  id: Int
  name: String
  status: DonationStatus
  updatedAt: DateTime
}

input DonationMaxOrderByAggregateInput {
  accountId: SortOrder
  amount: SortOrder
  approvedById: SortOrder
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  status: SortOrder
  updatedAt: SortOrder
}

type DonationMinAggregateOutputType {
  accountId: Int
  amount: Float
  approvedById: Int
  createdAt: DateTime
  id: Int
  name: String
  status: DonationStatus
  updatedAt: DateTime
}

input DonationMinOrderByAggregateInput {
  accountId: SortOrder
  amount: SortOrder
  approvedById: SortOrder
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  status: SortOrder
  updatedAt: SortOrder
}

input DonationOrderByRelationAggregateInput {
  _count: SortOrder
}

input DonationOrderByWithAggregationInput {
  _avg: DonationAvgOrderByAggregateInput
  _count: DonationCountOrderByAggregateInput
  _max: DonationMaxOrderByAggregateInput
  _min: DonationMinOrderByAggregateInput
  _sum: DonationSumOrderByAggregateInput
  accountId: SortOrder
  amount: SortOrder
  approvedById: SortOrder
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  status: SortOrder
  updatedAt: SortOrder
}

input DonationOrderByWithRelationInput {
  account: DonationAccountOrderByWithRelationInput
  accountId: SortOrder
  amount: SortOrder
  approvedBy: UserOrderByWithRelationInput
  approvedById: SortOrder
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  status: SortOrder
  updatedAt: SortOrder
}

enum DonationScalarFieldEnum {
  accountId
  amount
  approvedById
  createdAt
  id
  name
  status
  updatedAt
}

input DonationScalarWhereInput {
  AND: [DonationScalarWhereInput]
  NOT: [DonationScalarWhereInput]
  OR: [DonationScalarWhereInput]
  accountId: IntFilter
  amount: FloatFilter
  approvedById: IntNullableFilter
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  status: EnumDonationStatusFilter
  updatedAt: DateTimeFilter
}

input DonationScalarWhereWithAggregatesInput {
  AND: [DonationScalarWhereWithAggregatesInput]
  NOT: [DonationScalarWhereWithAggregatesInput]
  OR: [DonationScalarWhereWithAggregatesInput]
  accountId: IntWithAggregatesFilter
  amount: FloatWithAggregatesFilter
  approvedById: IntNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  status: EnumDonationStatusWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

enum DonationStatus {
  APPROVED
  PENDING
  REJECTED
}

type DonationSumAggregateOutputType {
  accountId: Int
  amount: Float
  approvedById: Int
  id: Int
}

input DonationSumOrderByAggregateInput {
  accountId: SortOrder
  amount: SortOrder
  approvedById: SortOrder
  id: SortOrder
}

input DonationUncheckedCreateInput {
  accountId: Int!
  amount: Float!
  approvedById: Int
  createdAt: DateTime
  id: Int
  name: String!
  status: DonationStatus!
  updatedAt: DateTime
}

input DonationUncheckedCreateNestedManyWithoutAccountInput {
  connect: [DonationWhereUniqueInput]
  connectOrCreate: [DonationCreateOrConnectWithoutAccountInput]
  create: [DonationCreateWithoutAccountInput]
  createMany: DonationCreateManyAccountInputEnvelope
}

input DonationUncheckedCreateNestedManyWithoutApprovedByInput {
  connect: [DonationWhereUniqueInput]
  connectOrCreate: [DonationCreateOrConnectWithoutApprovedByInput]
  create: [DonationCreateWithoutApprovedByInput]
  createMany: DonationCreateManyApprovedByInputEnvelope
}

input DonationUncheckedCreateWithoutAccountInput {
  amount: Float!
  approvedById: Int
  createdAt: DateTime
  id: Int
  name: String!
  status: DonationStatus!
  updatedAt: DateTime
}

input DonationUncheckedCreateWithoutApprovedByInput {
  accountId: Int!
  amount: Float!
  createdAt: DateTime
  id: Int
  name: String!
  status: DonationStatus!
  updatedAt: DateTime
}

input DonationUncheckedUpdateInput {
  accountId: IntFieldUpdateOperationsInput
  amount: FloatFieldUpdateOperationsInput
  approvedById: NullableIntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  status: EnumDonationStatusFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input DonationUncheckedUpdateManyInput {
  accountId: IntFieldUpdateOperationsInput
  amount: FloatFieldUpdateOperationsInput
  approvedById: NullableIntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  status: EnumDonationStatusFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input DonationUncheckedUpdateManyWithoutAccountInput {
  connect: [DonationWhereUniqueInput]
  connectOrCreate: [DonationCreateOrConnectWithoutAccountInput]
  create: [DonationCreateWithoutAccountInput]
  createMany: DonationCreateManyAccountInputEnvelope
  delete: [DonationWhereUniqueInput]
  deleteMany: [DonationScalarWhereInput]
  disconnect: [DonationWhereUniqueInput]
  set: [DonationWhereUniqueInput]
  update: [DonationUpdateWithWhereUniqueWithoutAccountInput]
  updateMany: [DonationUpdateManyWithWhereWithoutAccountInput]
  upsert: [DonationUpsertWithWhereUniqueWithoutAccountInput]
}

input DonationUncheckedUpdateManyWithoutApprovedByInput {
  connect: [DonationWhereUniqueInput]
  connectOrCreate: [DonationCreateOrConnectWithoutApprovedByInput]
  create: [DonationCreateWithoutApprovedByInput]
  createMany: DonationCreateManyApprovedByInputEnvelope
  delete: [DonationWhereUniqueInput]
  deleteMany: [DonationScalarWhereInput]
  disconnect: [DonationWhereUniqueInput]
  set: [DonationWhereUniqueInput]
  update: [DonationUpdateWithWhereUniqueWithoutApprovedByInput]
  updateMany: [DonationUpdateManyWithWhereWithoutApprovedByInput]
  upsert: [DonationUpsertWithWhereUniqueWithoutApprovedByInput]
}

input DonationUncheckedUpdateManyWithoutApprovedDonationsInput {
  accountId: IntFieldUpdateOperationsInput
  amount: FloatFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  status: EnumDonationStatusFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input DonationUncheckedUpdateManyWithoutDonationsInput {
  amount: FloatFieldUpdateOperationsInput
  approvedById: NullableIntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  status: EnumDonationStatusFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input DonationUncheckedUpdateWithoutAccountInput {
  amount: FloatFieldUpdateOperationsInput
  approvedById: NullableIntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  status: EnumDonationStatusFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input DonationUncheckedUpdateWithoutApprovedByInput {
  accountId: IntFieldUpdateOperationsInput
  amount: FloatFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  status: EnumDonationStatusFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input DonationUpdateInput {
  account: DonationAccountUpdateOneRequiredWithoutDonationsInput
  amount: FloatFieldUpdateOperationsInput
  approvedBy: UserUpdateOneWithoutApprovedDonationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  status: EnumDonationStatusFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input DonationUpdateManyMutationInput {
  amount: FloatFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  status: EnumDonationStatusFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input DonationUpdateManyWithWhereWithoutAccountInput {
  data: DonationUncheckedUpdateManyWithoutDonationsInput!
  where: DonationScalarWhereInput!
}

input DonationUpdateManyWithWhereWithoutApprovedByInput {
  data: DonationUncheckedUpdateManyWithoutApprovedDonationsInput!
  where: DonationScalarWhereInput!
}

input DonationUpdateManyWithoutAccountInput {
  connect: [DonationWhereUniqueInput]
  connectOrCreate: [DonationCreateOrConnectWithoutAccountInput]
  create: [DonationCreateWithoutAccountInput]
  createMany: DonationCreateManyAccountInputEnvelope
  delete: [DonationWhereUniqueInput]
  deleteMany: [DonationScalarWhereInput]
  disconnect: [DonationWhereUniqueInput]
  set: [DonationWhereUniqueInput]
  update: [DonationUpdateWithWhereUniqueWithoutAccountInput]
  updateMany: [DonationUpdateManyWithWhereWithoutAccountInput]
  upsert: [DonationUpsertWithWhereUniqueWithoutAccountInput]
}

input DonationUpdateManyWithoutApprovedByInput {
  connect: [DonationWhereUniqueInput]
  connectOrCreate: [DonationCreateOrConnectWithoutApprovedByInput]
  create: [DonationCreateWithoutApprovedByInput]
  createMany: DonationCreateManyApprovedByInputEnvelope
  delete: [DonationWhereUniqueInput]
  deleteMany: [DonationScalarWhereInput]
  disconnect: [DonationWhereUniqueInput]
  set: [DonationWhereUniqueInput]
  update: [DonationUpdateWithWhereUniqueWithoutApprovedByInput]
  updateMany: [DonationUpdateManyWithWhereWithoutApprovedByInput]
  upsert: [DonationUpsertWithWhereUniqueWithoutApprovedByInput]
}

input DonationUpdateWithWhereUniqueWithoutAccountInput {
  data: DonationUncheckedUpdateWithoutAccountInput!
  where: DonationWhereUniqueInput!
}

input DonationUpdateWithWhereUniqueWithoutApprovedByInput {
  data: DonationUncheckedUpdateWithoutApprovedByInput!
  where: DonationWhereUniqueInput!
}

input DonationUpdateWithoutAccountInput {
  amount: FloatFieldUpdateOperationsInput
  approvedBy: UserUpdateOneWithoutApprovedDonationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  status: EnumDonationStatusFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input DonationUpdateWithoutApprovedByInput {
  account: DonationAccountUpdateOneRequiredWithoutDonationsInput
  amount: FloatFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  status: EnumDonationStatusFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input DonationUpsertWithWhereUniqueWithoutAccountInput {
  create: DonationUncheckedCreateWithoutAccountInput!
  update: DonationUncheckedUpdateWithoutAccountInput!
  where: DonationWhereUniqueInput!
}

input DonationUpsertWithWhereUniqueWithoutApprovedByInput {
  create: DonationUncheckedCreateWithoutApprovedByInput!
  update: DonationUncheckedUpdateWithoutApprovedByInput!
  where: DonationWhereUniqueInput!
}

input DonationWhereInput {
  AND: [DonationWhereInput]
  NOT: [DonationWhereInput]
  OR: [DonationWhereInput]
  account: DonationAccountWhereInput
  accountId: IntFilter
  amount: FloatFilter
  approvedBy: UserWhereInput
  approvedById: IntNullableFilter
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  status: EnumDonationStatusFilter
  updatedAt: DateTimeFilter
}

input DonationWhereUniqueInput {
  id: Int
}

input EnumDonationStatusFieldUpdateOperationsInput {
  set: DonationStatus
}

input EnumDonationStatusFilter {
  equals: DonationStatus
  in: [DonationStatus]
  not: NestedEnumDonationStatusFilter
  notIn: [DonationStatus]
}

input EnumDonationStatusWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumDonationStatusFilter
  _min: NestedEnumDonationStatusFilter
  equals: DonationStatus
  in: [DonationStatus]
  not: NestedEnumDonationStatusWithAggregatesFilter
  notIn: [DonationStatus]
}

input EnumRolesFieldUpdateOperationsInput {
  set: Roles
}

input EnumRolesFilter {
  equals: Roles
  in: [Roles]
  not: NestedEnumRolesFilter
  notIn: [Roles]
}

input EnumRolesWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRolesFilter
  _min: NestedEnumRolesFilter
  equals: Roles
  in: [Roles]
  not: NestedEnumRolesWithAggregatesFilter
  notIn: [Roles]
}

input FloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float]
}

input FloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int]
}

"""Json custom scalar type"""
scalar Json

type Mutation {
  createOneCategory(data: CategoryCreateInput!): Category!
  createOneDonation(data: DonationCreateInput!): Donation!
  createOneDonationAccount(data: DonationAccountCreateInput!): DonationAccount!
  createOneNews(data: NewsCreateInput!): News!
  createOneUser(data: UserCreateInput!): User!
  deleteManyCategory(where: CategoryWhereInput): BatchPayload!
  deleteManyDonation(where: DonationWhereInput): BatchPayload!
  deleteManyDonationAccount(where: DonationAccountWhereInput): BatchPayload!
  deleteManyNews(where: NewsWhereInput): BatchPayload!
  deleteManyUser(where: UserWhereInput): BatchPayload!
  deleteOneCategory(where: CategoryWhereUniqueInput!): Category
  deleteOneDonation(where: DonationWhereUniqueInput!): Donation
  deleteOneDonationAccount(where: DonationAccountWhereUniqueInput!): DonationAccount
  deleteOneNews(where: NewsWhereUniqueInput!): News
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyCategory(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): BatchPayload!
  updateManyDonation(data: DonationUpdateManyMutationInput!, where: DonationWhereInput): BatchPayload!
  updateManyDonationAccount(data: DonationAccountUpdateManyMutationInput!, where: DonationAccountWhereInput): BatchPayload!
  updateManyNews(data: NewsUpdateManyMutationInput!, where: NewsWhereInput): BatchPayload!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateOneCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category!
  updateOneDonation(data: DonationUpdateInput!, where: DonationWhereUniqueInput!): Donation!
  updateOneDonationAccount(data: DonationAccountUpdateInput!, where: DonationAccountWhereUniqueInput!): DonationAccount!
  updateOneNews(data: NewsUpdateInput!, where: NewsWhereUniqueInput!): News!
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  upsertOneCategory(create: CategoryCreateInput!, update: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category!
  upsertOneDonation(create: DonationCreateInput!, update: DonationUpdateInput!, where: DonationWhereUniqueInput!): Donation!
  upsertOneDonationAccount(create: DonationAccountCreateInput!, update: DonationAccountUpdateInput!, where: DonationAccountWhereUniqueInput!): DonationAccount!
  upsertOneNews(create: NewsCreateInput!, update: NewsUpdateInput!, where: NewsWhereUniqueInput!): News!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime]
}

input NestedEnumDonationStatusFilter {
  equals: DonationStatus
  in: [DonationStatus]
  not: NestedEnumDonationStatusFilter
  notIn: [DonationStatus]
}

input NestedEnumDonationStatusWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumDonationStatusFilter
  _min: NestedEnumDonationStatusFilter
  equals: DonationStatus
  in: [DonationStatus]
  not: NestedEnumDonationStatusWithAggregatesFilter
  notIn: [DonationStatus]
}

input NestedEnumRolesFilter {
  equals: Roles
  in: [Roles]
  not: NestedEnumRolesFilter
  notIn: [Roles]
}

input NestedEnumRolesWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRolesFilter
  _min: NestedEnumRolesFilter
  equals: Roles
  in: [Roles]
  not: NestedEnumRolesWithAggregatesFilter
  notIn: [Roles]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float]
}

input NestedFloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

type News {
  _count: NewsCountOutputType!
  author: User
  authorId: Int
  categories(cursor: CategoryWhereUniqueInput, distinct: CategoryScalarFieldEnum, orderBy: CategoryOrderByWithRelationInput, skip: Int, take: Int, where: CategoryWhereInput): [Category!]!
  createdAt: DateTime!
  id: Int!
  published: Boolean!
  title: String!
  updatedAt: DateTime!
}

type NewsAvgAggregateOutputType {
  authorId: Float
  id: Float
}

input NewsAvgOrderByAggregateInput {
  authorId: SortOrder
  id: SortOrder
}

type NewsCountAggregateOutputType {
  _all: Int!
  authorId: Int!
  createdAt: Int!
  id: Int!
  published: Int!
  title: Int!
  updatedAt: Int!
}

input NewsCountOrderByAggregateInput {
  authorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  published: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

type NewsCountOutputType {
  categories: Int!
}

input NewsCreateInput {
  author: UserCreateNestedOneWithoutNewsInput
  categories: CategoryCreateNestedManyWithoutNewsInput
  createdAt: DateTime
  published: Boolean
  title: String!
  updatedAt: DateTime
}

input NewsCreateManyAuthorInput {
  createdAt: DateTime
  id: Int
  published: Boolean
  title: String!
  updatedAt: DateTime
}

input NewsCreateManyAuthorInputEnvelope {
  data: NewsCreateManyAuthorInput!
  skipDuplicates: Boolean
}

input NewsCreateManyInput {
  authorId: Int
  createdAt: DateTime
  id: Int
  published: Boolean
  title: String!
  updatedAt: DateTime
}

input NewsCreateNestedManyWithoutAuthorInput {
  connect: [NewsWhereUniqueInput]
  connectOrCreate: [NewsCreateOrConnectWithoutAuthorInput]
  create: [NewsCreateWithoutAuthorInput]
  createMany: NewsCreateManyAuthorInputEnvelope
}

input NewsCreateNestedManyWithoutCategoriesInput {
  connect: [NewsWhereUniqueInput]
  connectOrCreate: [NewsCreateOrConnectWithoutCategoriesInput]
  create: [NewsCreateWithoutCategoriesInput]
}

input NewsCreateOrConnectWithoutAuthorInput {
  create: NewsUncheckedCreateWithoutAuthorInput!
  where: NewsWhereUniqueInput!
}

input NewsCreateOrConnectWithoutCategoriesInput {
  create: NewsUncheckedCreateWithoutCategoriesInput!
  where: NewsWhereUniqueInput!
}

input NewsCreateWithoutAuthorInput {
  categories: CategoryCreateNestedManyWithoutNewsInput
  createdAt: DateTime
  published: Boolean
  title: String!
  updatedAt: DateTime
}

input NewsCreateWithoutCategoriesInput {
  author: UserCreateNestedOneWithoutNewsInput
  createdAt: DateTime
  published: Boolean
  title: String!
  updatedAt: DateTime
}

input NewsListRelationFilter {
  every: NewsWhereInput
  none: NewsWhereInput
  some: NewsWhereInput
}

type NewsMaxAggregateOutputType {
  authorId: Int
  createdAt: DateTime
  id: Int
  published: Boolean
  title: String
  updatedAt: DateTime
}

input NewsMaxOrderByAggregateInput {
  authorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  published: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

type NewsMinAggregateOutputType {
  authorId: Int
  createdAt: DateTime
  id: Int
  published: Boolean
  title: String
  updatedAt: DateTime
}

input NewsMinOrderByAggregateInput {
  authorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  published: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input NewsOrderByRelationAggregateInput {
  _count: SortOrder
}

input NewsOrderByWithAggregationInput {
  _avg: NewsAvgOrderByAggregateInput
  _count: NewsCountOrderByAggregateInput
  _max: NewsMaxOrderByAggregateInput
  _min: NewsMinOrderByAggregateInput
  _sum: NewsSumOrderByAggregateInput
  authorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  published: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input NewsOrderByWithRelationInput {
  author: UserOrderByWithRelationInput
  authorId: SortOrder
  categories: CategoryOrderByRelationAggregateInput
  createdAt: SortOrder
  id: SortOrder
  published: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

enum NewsScalarFieldEnum {
  authorId
  createdAt
  id
  published
  title
  updatedAt
}

input NewsScalarWhereInput {
  AND: [NewsScalarWhereInput]
  NOT: [NewsScalarWhereInput]
  OR: [NewsScalarWhereInput]
  authorId: IntNullableFilter
  createdAt: DateTimeFilter
  id: IntFilter
  published: BoolFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input NewsScalarWhereWithAggregatesInput {
  AND: [NewsScalarWhereWithAggregatesInput]
  NOT: [NewsScalarWhereWithAggregatesInput]
  OR: [NewsScalarWhereWithAggregatesInput]
  authorId: IntNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  published: BoolWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type NewsSumAggregateOutputType {
  authorId: Int
  id: Int
}

input NewsSumOrderByAggregateInput {
  authorId: SortOrder
  id: SortOrder
}

input NewsUncheckedCreateInput {
  authorId: Int
  categories: CategoryUncheckedCreateNestedManyWithoutNewsInput
  createdAt: DateTime
  id: Int
  published: Boolean
  title: String!
  updatedAt: DateTime
}

input NewsUncheckedCreateNestedManyWithoutAuthorInput {
  connect: [NewsWhereUniqueInput]
  connectOrCreate: [NewsCreateOrConnectWithoutAuthorInput]
  create: [NewsCreateWithoutAuthorInput]
  createMany: NewsCreateManyAuthorInputEnvelope
}

input NewsUncheckedCreateNestedManyWithoutCategoriesInput {
  connect: [NewsWhereUniqueInput]
  connectOrCreate: [NewsCreateOrConnectWithoutCategoriesInput]
  create: [NewsCreateWithoutCategoriesInput]
}

input NewsUncheckedCreateWithoutAuthorInput {
  categories: CategoryUncheckedCreateNestedManyWithoutNewsInput
  createdAt: DateTime
  id: Int
  published: Boolean
  title: String!
  updatedAt: DateTime
}

input NewsUncheckedCreateWithoutCategoriesInput {
  authorId: Int
  createdAt: DateTime
  id: Int
  published: Boolean
  title: String!
  updatedAt: DateTime
}

input NewsUncheckedUpdateInput {
  authorId: NullableIntFieldUpdateOperationsInput
  categories: CategoryUncheckedUpdateManyWithoutNewsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input NewsUncheckedUpdateManyInput {
  authorId: NullableIntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input NewsUncheckedUpdateManyWithoutAuthorInput {
  connect: [NewsWhereUniqueInput]
  connectOrCreate: [NewsCreateOrConnectWithoutAuthorInput]
  create: [NewsCreateWithoutAuthorInput]
  createMany: NewsCreateManyAuthorInputEnvelope
  delete: [NewsWhereUniqueInput]
  deleteMany: [NewsScalarWhereInput]
  disconnect: [NewsWhereUniqueInput]
  set: [NewsWhereUniqueInput]
  update: [NewsUpdateWithWhereUniqueWithoutAuthorInput]
  updateMany: [NewsUpdateManyWithWhereWithoutAuthorInput]
  upsert: [NewsUpsertWithWhereUniqueWithoutAuthorInput]
}

input NewsUncheckedUpdateManyWithoutCategoriesInput {
  connect: [NewsWhereUniqueInput]
  connectOrCreate: [NewsCreateOrConnectWithoutCategoriesInput]
  create: [NewsCreateWithoutCategoriesInput]
  delete: [NewsWhereUniqueInput]
  deleteMany: [NewsScalarWhereInput]
  disconnect: [NewsWhereUniqueInput]
  set: [NewsWhereUniqueInput]
  update: [NewsUpdateWithWhereUniqueWithoutCategoriesInput]
  updateMany: [NewsUpdateManyWithWhereWithoutCategoriesInput]
  upsert: [NewsUpsertWithWhereUniqueWithoutCategoriesInput]
}

input NewsUncheckedUpdateManyWithoutNewsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input NewsUncheckedUpdateWithoutAuthorInput {
  categories: CategoryUncheckedUpdateManyWithoutNewsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input NewsUncheckedUpdateWithoutCategoriesInput {
  authorId: NullableIntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input NewsUpdateInput {
  author: UserUpdateOneWithoutNewsInput
  categories: CategoryUpdateManyWithoutNewsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input NewsUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input NewsUpdateManyWithWhereWithoutAuthorInput {
  data: NewsUncheckedUpdateManyWithoutNewsInput!
  where: NewsScalarWhereInput!
}

input NewsUpdateManyWithWhereWithoutCategoriesInput {
  data: NewsUncheckedUpdateManyWithoutNewsInput!
  where: NewsScalarWhereInput!
}

input NewsUpdateManyWithoutAuthorInput {
  connect: [NewsWhereUniqueInput]
  connectOrCreate: [NewsCreateOrConnectWithoutAuthorInput]
  create: [NewsCreateWithoutAuthorInput]
  createMany: NewsCreateManyAuthorInputEnvelope
  delete: [NewsWhereUniqueInput]
  deleteMany: [NewsScalarWhereInput]
  disconnect: [NewsWhereUniqueInput]
  set: [NewsWhereUniqueInput]
  update: [NewsUpdateWithWhereUniqueWithoutAuthorInput]
  updateMany: [NewsUpdateManyWithWhereWithoutAuthorInput]
  upsert: [NewsUpsertWithWhereUniqueWithoutAuthorInput]
}

input NewsUpdateManyWithoutCategoriesInput {
  connect: [NewsWhereUniqueInput]
  connectOrCreate: [NewsCreateOrConnectWithoutCategoriesInput]
  create: [NewsCreateWithoutCategoriesInput]
  delete: [NewsWhereUniqueInput]
  deleteMany: [NewsScalarWhereInput]
  disconnect: [NewsWhereUniqueInput]
  set: [NewsWhereUniqueInput]
  update: [NewsUpdateWithWhereUniqueWithoutCategoriesInput]
  updateMany: [NewsUpdateManyWithWhereWithoutCategoriesInput]
  upsert: [NewsUpsertWithWhereUniqueWithoutCategoriesInput]
}

input NewsUpdateWithWhereUniqueWithoutAuthorInput {
  data: NewsUncheckedUpdateWithoutAuthorInput!
  where: NewsWhereUniqueInput!
}

input NewsUpdateWithWhereUniqueWithoutCategoriesInput {
  data: NewsUncheckedUpdateWithoutCategoriesInput!
  where: NewsWhereUniqueInput!
}

input NewsUpdateWithoutAuthorInput {
  categories: CategoryUpdateManyWithoutNewsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input NewsUpdateWithoutCategoriesInput {
  author: UserUpdateOneWithoutNewsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input NewsUpsertWithWhereUniqueWithoutAuthorInput {
  create: NewsUncheckedCreateWithoutAuthorInput!
  update: NewsUncheckedUpdateWithoutAuthorInput!
  where: NewsWhereUniqueInput!
}

input NewsUpsertWithWhereUniqueWithoutCategoriesInput {
  create: NewsUncheckedCreateWithoutCategoriesInput!
  update: NewsUncheckedUpdateWithoutCategoriesInput!
  where: NewsWhereUniqueInput!
}

input NewsWhereInput {
  AND: [NewsWhereInput]
  NOT: [NewsWhereInput]
  OR: [NewsWhereInput]
  author: UserWhereInput
  authorId: IntNullableFilter
  categories: CategoryListRelationFilter
  createdAt: DateTimeFilter
  id: IntFilter
  published: BoolFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input NewsWhereUniqueInput {
  id: Int
}

input NullableIntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  aggregateCategory(cursor: CategoryWhereUniqueInput, orderBy: [CategoryOrderByWithRelationInput], skip: Int, take: Int, where: CategoryWhereInput): AggregateCategory
  aggregateDonation(cursor: DonationWhereUniqueInput, orderBy: [DonationOrderByWithRelationInput], skip: Int, take: Int, where: DonationWhereInput): AggregateDonation
  aggregateDonationAccount(cursor: DonationAccountWhereUniqueInput, orderBy: [DonationAccountOrderByWithRelationInput], skip: Int, take: Int, where: DonationAccountWhereInput): AggregateDonationAccount
  aggregateNews(cursor: NewsWhereUniqueInput, orderBy: [NewsOrderByWithRelationInput], skip: Int, take: Int, where: NewsWhereInput): AggregateNews
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput], skip: Int, take: Int, where: UserWhereInput): AggregateUser
  findFirstCategory(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum], orderBy: [CategoryOrderByWithRelationInput], skip: Int, take: Int, where: CategoryWhereInput): Category
  findFirstDonation(cursor: DonationWhereUniqueInput, distinct: [DonationScalarFieldEnum], orderBy: [DonationOrderByWithRelationInput], skip: Int, take: Int, where: DonationWhereInput): Donation
  findFirstDonationAccount(cursor: DonationAccountWhereUniqueInput, distinct: [DonationAccountScalarFieldEnum], orderBy: [DonationAccountOrderByWithRelationInput], skip: Int, take: Int, where: DonationAccountWhereInput): DonationAccount
  findFirstNews(cursor: NewsWhereUniqueInput, distinct: [NewsScalarFieldEnum], orderBy: [NewsOrderByWithRelationInput], skip: Int, take: Int, where: NewsWhereInput): News
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum], orderBy: [UserOrderByWithRelationInput], skip: Int, take: Int, where: UserWhereInput): User
  findManyCategory(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum], orderBy: [CategoryOrderByWithRelationInput], skip: Int, take: Int, where: CategoryWhereInput): [Category!]!
  findManyCategoryCount(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum], orderBy: [CategoryOrderByWithRelationInput], skip: Int, take: Int, where: CategoryWhereInput): Int!
  findManyDonation(cursor: DonationWhereUniqueInput, distinct: [DonationScalarFieldEnum], orderBy: [DonationOrderByWithRelationInput], skip: Int, take: Int, where: DonationWhereInput): [Donation!]!
  findManyDonationAccount(cursor: DonationAccountWhereUniqueInput, distinct: [DonationAccountScalarFieldEnum], orderBy: [DonationAccountOrderByWithRelationInput], skip: Int, take: Int, where: DonationAccountWhereInput): [DonationAccount!]!
  findManyDonationAccountCount(cursor: DonationAccountWhereUniqueInput, distinct: [DonationAccountScalarFieldEnum], orderBy: [DonationAccountOrderByWithRelationInput], skip: Int, take: Int, where: DonationAccountWhereInput): Int!
  findManyDonationCount(cursor: DonationWhereUniqueInput, distinct: [DonationScalarFieldEnum], orderBy: [DonationOrderByWithRelationInput], skip: Int, take: Int, where: DonationWhereInput): Int!
  findManyNews(cursor: NewsWhereUniqueInput, distinct: [NewsScalarFieldEnum], orderBy: [NewsOrderByWithRelationInput], skip: Int, take: Int, where: NewsWhereInput): [News!]!
  findManyNewsCount(cursor: NewsWhereUniqueInput, distinct: [NewsScalarFieldEnum], orderBy: [NewsOrderByWithRelationInput], skip: Int, take: Int, where: NewsWhereInput): Int!
  findManyUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum], orderBy: [UserOrderByWithRelationInput], skip: Int, take: Int, where: UserWhereInput): [User!]!
  findManyUserCount(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum], orderBy: [UserOrderByWithRelationInput], skip: Int, take: Int, where: UserWhereInput): Int!
  findUniqueCategory(where: CategoryWhereUniqueInput!): Category
  findUniqueDonation(where: DonationWhereUniqueInput!): Donation
  findUniqueDonationAccount(where: DonationAccountWhereUniqueInput!): DonationAccount
  findUniqueNews(where: NewsWhereUniqueInput!): News
  findUniqueUser(where: UserWhereUniqueInput!): User
}

enum QueryMode {
  default
  insensitive
}

enum Roles {
  ADMIN
  EDITOR
  MASTER_ADMIN
  USER
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

type User {
  _count: UserCountOutputType!
  approvedDonations(cursor: DonationWhereUniqueInput, distinct: DonationScalarFieldEnum, orderBy: DonationOrderByWithRelationInput, skip: Int, take: Int, where: DonationWhereInput): [Donation!]!
  createdAt: DateTime!
  email: String!
  groupId: Int
  id: Int!
  isAdmin: Boolean!
  name: String
  news(cursor: NewsWhereUniqueInput, distinct: NewsScalarFieldEnum, orderBy: NewsOrderByWithRelationInput, skip: Int, take: Int, where: NewsWhereInput): [News!]!
  password: String!
  roles: Roles!
  showOnHomepage: Boolean!
}

type UserAvgAggregateOutputType {
  groupId: Float
  id: Float
}

input UserAvgOrderByAggregateInput {
  groupId: SortOrder
  id: SortOrder
}

type UserCountAggregateOutputType {
  _all: Int!
  createdAt: Int!
  email: Int!
  groupId: Int!
  id: Int!
  isAdmin: Int!
  name: Int!
  roles: Int!
  showOnHomepage: Int!
}

input UserCountOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  groupId: SortOrder
  id: SortOrder
  isAdmin: SortOrder
  name: SortOrder
  roles: SortOrder
  showOnHomepage: SortOrder
}

type UserCountOutputType {
  approvedDonations: Int!
  news: Int!
}

input UserCreateInput {
  approvedDonations: DonationCreateNestedManyWithoutApprovedByInput
  createdAt: DateTime
  email: String!
  groupId: Int
  isAdmin: Boolean
  name: String
  news: NewsCreateNestedManyWithoutAuthorInput
  roles: Roles!
  showOnHomepage: Boolean
}

input UserCreateManyInput {
  createdAt: DateTime
  email: String!
  groupId: Int
  id: Int
  isAdmin: Boolean
  name: String
  roles: Roles!
  showOnHomepage: Boolean
}

input UserCreateNestedOneWithoutApprovedDonationsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutApprovedDonationsInput
  create: UserUncheckedCreateWithoutApprovedDonationsInput
}

input UserCreateNestedOneWithoutNewsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutNewsInput
  create: UserUncheckedCreateWithoutNewsInput
}

input UserCreateOrConnectWithoutApprovedDonationsInput {
  create: UserUncheckedCreateWithoutApprovedDonationsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutNewsInput {
  create: UserUncheckedCreateWithoutNewsInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutApprovedDonationsInput {
  createdAt: DateTime
  email: String!
  groupId: Int
  isAdmin: Boolean
  name: String
  news: NewsCreateNestedManyWithoutAuthorInput
  roles: Roles!
  showOnHomepage: Boolean
}

input UserCreateWithoutNewsInput {
  approvedDonations: DonationCreateNestedManyWithoutApprovedByInput
  createdAt: DateTime
  email: String!
  groupId: Int
  isAdmin: Boolean
  name: String
  roles: Roles!
  showOnHomepage: Boolean
}

type UserMaxAggregateOutputType {
  createdAt: DateTime
  email: String
  groupId: Int
  id: Int
  isAdmin: Boolean
  name: String
  roles: Roles
  showOnHomepage: Boolean
}

input UserMaxOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  groupId: SortOrder
  id: SortOrder
  isAdmin: SortOrder
  name: SortOrder
  roles: SortOrder
  showOnHomepage: SortOrder
}

type UserMinAggregateOutputType {
  createdAt: DateTime
  email: String
  groupId: Int
  id: Int
  isAdmin: Boolean
  name: String
  roles: Roles
  showOnHomepage: Boolean
}

input UserMinOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  groupId: SortOrder
  id: SortOrder
  isAdmin: SortOrder
  name: SortOrder
  roles: SortOrder
  showOnHomepage: SortOrder
}

input UserOrderByWithAggregationInput {
  _avg: UserAvgOrderByAggregateInput
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
  createdAt: SortOrder
  email: SortOrder
  groupId: SortOrder
  id: SortOrder
  isAdmin: SortOrder
  name: SortOrder
  roles: SortOrder
  showOnHomepage: SortOrder
}

input UserOrderByWithRelationInput {
  approvedDonations: DonationOrderByRelationAggregateInput
  createdAt: SortOrder
  email: SortOrder
  groupId: SortOrder
  id: SortOrder
  isAdmin: SortOrder
  name: SortOrder
  news: NewsOrderByRelationAggregateInput
  roles: SortOrder
  showOnHomepage: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  email
  groupId
  id
  isAdmin
  name
  password
  roles
  showOnHomepage
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput]
  NOT: [UserScalarWhereWithAggregatesInput]
  OR: [UserScalarWhereWithAggregatesInput]
  createdAt: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  groupId: IntNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  isAdmin: BoolWithAggregatesFilter
  name: StringNullableWithAggregatesFilter
  roles: EnumRolesWithAggregatesFilter
  showOnHomepage: BoolWithAggregatesFilter
}

type UserSumAggregateOutputType {
  groupId: Int
  id: Int
}

input UserSumOrderByAggregateInput {
  groupId: SortOrder
  id: SortOrder
}

input UserUncheckedCreateInput {
  approvedDonations: DonationUncheckedCreateNestedManyWithoutApprovedByInput
  createdAt: DateTime
  email: String!
  groupId: Int
  id: Int
  isAdmin: Boolean
  name: String
  news: NewsUncheckedCreateNestedManyWithoutAuthorInput
  roles: Roles!
  showOnHomepage: Boolean
}

input UserUncheckedCreateWithoutApprovedDonationsInput {
  createdAt: DateTime
  email: String!
  groupId: Int
  id: Int
  isAdmin: Boolean
  name: String
  news: NewsUncheckedCreateNestedManyWithoutAuthorInput
  roles: Roles!
  showOnHomepage: Boolean
}

input UserUncheckedCreateWithoutNewsInput {
  approvedDonations: DonationUncheckedCreateNestedManyWithoutApprovedByInput
  createdAt: DateTime
  email: String!
  groupId: Int
  id: Int
  isAdmin: Boolean
  name: String
  roles: Roles!
  showOnHomepage: Boolean
}

input UserUncheckedUpdateInput {
  approvedDonations: DonationUncheckedUpdateManyWithoutApprovedByInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  groupId: NullableIntFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  isAdmin: BoolFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  news: NewsUncheckedUpdateManyWithoutAuthorInput
  roles: EnumRolesFieldUpdateOperationsInput
  showOnHomepage: BoolFieldUpdateOperationsInput
}

input UserUncheckedUpdateManyInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  groupId: NullableIntFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  isAdmin: BoolFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  roles: EnumRolesFieldUpdateOperationsInput
  showOnHomepage: BoolFieldUpdateOperationsInput
}

input UserUncheckedUpdateWithoutApprovedDonationsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  groupId: NullableIntFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  isAdmin: BoolFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  news: NewsUncheckedUpdateManyWithoutAuthorInput
  roles: EnumRolesFieldUpdateOperationsInput
  showOnHomepage: BoolFieldUpdateOperationsInput
}

input UserUncheckedUpdateWithoutNewsInput {
  approvedDonations: DonationUncheckedUpdateManyWithoutApprovedByInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  groupId: NullableIntFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  isAdmin: BoolFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  roles: EnumRolesFieldUpdateOperationsInput
  showOnHomepage: BoolFieldUpdateOperationsInput
}

input UserUpdateInput {
  approvedDonations: DonationUpdateManyWithoutApprovedByInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  groupId: NullableIntFieldUpdateOperationsInput
  isAdmin: BoolFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  news: NewsUpdateManyWithoutAuthorInput
  roles: EnumRolesFieldUpdateOperationsInput
  showOnHomepage: BoolFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  groupId: NullableIntFieldUpdateOperationsInput
  isAdmin: BoolFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  roles: EnumRolesFieldUpdateOperationsInput
  showOnHomepage: BoolFieldUpdateOperationsInput
}

input UserUpdateOneWithoutApprovedDonationsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutApprovedDonationsInput
  create: UserUncheckedCreateWithoutApprovedDonationsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUncheckedUpdateWithoutApprovedDonationsInput
  upsert: UserUpsertWithoutApprovedDonationsInput
}

input UserUpdateOneWithoutNewsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutNewsInput
  create: UserUncheckedCreateWithoutNewsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUncheckedUpdateWithoutNewsInput
  upsert: UserUpsertWithoutNewsInput
}

input UserUpdateWithoutApprovedDonationsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  groupId: NullableIntFieldUpdateOperationsInput
  isAdmin: BoolFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  news: NewsUpdateManyWithoutAuthorInput
  roles: EnumRolesFieldUpdateOperationsInput
  showOnHomepage: BoolFieldUpdateOperationsInput
}

input UserUpdateWithoutNewsInput {
  approvedDonations: DonationUpdateManyWithoutApprovedByInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  groupId: NullableIntFieldUpdateOperationsInput
  isAdmin: BoolFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  roles: EnumRolesFieldUpdateOperationsInput
  showOnHomepage: BoolFieldUpdateOperationsInput
}

input UserUpsertWithoutApprovedDonationsInput {
  create: UserUncheckedCreateWithoutApprovedDonationsInput!
  update: UserUncheckedUpdateWithoutApprovedDonationsInput!
}

input UserUpsertWithoutNewsInput {
  create: UserUncheckedCreateWithoutNewsInput!
  update: UserUncheckedUpdateWithoutNewsInput!
}

input UserWhereInput {
  AND: [UserWhereInput]
  NOT: [UserWhereInput]
  OR: [UserWhereInput]
  approvedDonations: DonationListRelationFilter
  createdAt: DateTimeFilter
  email: StringFilter
  groupId: IntNullableFilter
  id: IntFilter
  isAdmin: BoolFilter
  name: StringNullableFilter
  news: NewsListRelationFilter
  roles: EnumRolesFilter
  showOnHomepage: BoolFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}